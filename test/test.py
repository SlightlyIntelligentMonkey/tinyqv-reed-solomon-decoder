# SPDX-FileCopyrightText: Â© 2025 Tiny Tapeout
# SPDX-License-Identifier: Apache-2.0

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import ClockCycles

from tqv import TinyQV
import math

# When submitting your design, change this to the peripheral number
# in peripherals.v.  e.g. if your design is i_user_peri05, set this to 5.
# The peripheral number is not used by the test harness.
PERIPHERAL_NUM = 0

msg_encoded = [ 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x0a, 0x54, 0x68, 0x69,
                0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x70, 0x69, 0x63, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x2e, 0x0a, 0x53, 0x65, 0x65, 0x20, 0x6d, 0x79, 0x20, 0x72, 0x65, 0x65, 0x64, 0x20, 0x73,
                0x6f, 0x6c, 0x6f, 0x6d, 0x6f, 0x6e, 0x20, 0x64, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x72, 0x20, 0x61,
                0x6e, 0x64, 0x20, 0x72, 0x65, 0x6a, 0x6f, 0x69, 0x63, 0x65, 0x21, 0x0a, 0x46, 0x6f, 0x72, 0x20,
                0x69, 0x74, 0x20, 0x73, 0x68, 0x61, 0x6c, 0x6c, 0x20, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x66, 0x69,
                0x72, 0x73, 0x74, 0x20, 0x74, 0x72, 0x79, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20,
                0x74, 0x61, 0x6b, 0x65, 0x20, 0x6d, 0x75, 0x63, 0x68, 0x20, 0x65, 0x66, 0x66, 0x6f, 0x72, 0x74,
                0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20,
                0x64, 0x6f, 0x65, 0x73, 0x6e, 0x27, 0x74, 0x20, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x66, 0x69, 0x72,
                0x73, 0x74, 0x20, 0x74, 0x72, 0x79, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x2e, 0x2d, 0x2e,
                0x2e, 0x20, 0x2d, 0x2d, 0x2d, 0x20, 0x2d, 0x2e, 0x20, 0x2d, 0x2e, 0x2e, 0x20, 0x2d, 0x2d, 0x2d,
                0x20, 0x2d, 0x2e, 0x20, 0x2d, 0x2e, 0x2d, 0x2e, 0x20, 0x2e, 0x2d, 0x20, 0x2e, 0x2d, 0x2e, 0x2e,
                0x20, 0x2e, 0x2d, 0x2e, 0x2e, 0x20, 0x2e, 0x2e, 0x20, 0x2d, 0x2e, 0x20, 0x2d, 0x2d, 0x2e, 0x81,
                0xd0, 0x52, 0x54, 0xa0, 0xa6, 0x44, 0x17, 0x8c, 0x4f, 0x76, 0x47, 0xed, 0x99, 0x9f, 0xbc, 0xd3,
                0x38, 0x61, 0x0f, 0xce, 0x0c, 0x17, 0x5f, 0x55, 0x3b, 0x3e, 0x90, 0x84, 0x13, 0xd6, 0x2d]

#msg_decoded = [ 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x0a, 0x54, 0x68, 0x69,
#                0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x70, 0x69, 0x63, 0x20, 0x74, 0x65, 0x73,
#                0x74, 0x2e, 0x0a, 0x53, 0x65, 0x65, 0x20, 0x6d, 0x79, 0x20, 0x72, 0x65, 0x65, 0x64, 0x20, 0x73,
#                0x6f, 0x6c, 0x6f, 0x6d, 0x6f, 0x6e, 0x20, 0x64, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x72, 0x20, 0x61,
#                0x6e, 0x64, 0x20, 0x72, 0x65, 0x6a, 0x6f, 0x69, 0x63, 0x65, 0x21, 0x0a, 0x46, 0x6f, 0x72, 0x20,
#                0x69, 0x74, 0x20, 0x73, 0x68, 0x61, 0x6c, 0x6c, 0x20, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x66, 0x69,
#                0x72, 0x73, 0x74, 0x20, 0x74, 0x72, 0x79, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20,
#                0x74, 0x61, 0x6b, 0x65, 0x20, 0x6d, 0x75, 0x63, 0x68, 0x20, 0x65, 0x66, 0x66, 0x6f, 0x72, 0x74,
#                0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20,
#                0x64, 0x6f, 0x65, 0x73, 0x6e, 0x27, 0x74, 0x20, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x66, 0x69, 0x72,
#                0x73, 0x74, 0x20, 0x74, 0x72, 0x79, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x2e, 0x2d, 0x2e,
#                0x2e, 0x20, 0x2d, 0x2d, 0x2d, 0x20, 0x2d, 0x2e, 0x20, 0x2d, 0x2e, 0x2e, 0x20, 0x2d, 0x2d, 0x2d,
#                0x20, 0x2d, 0x2e, 0x20, 0x2d, 0x2e, 0x2d, 0x2e, 0x20, 0x2e, 0x2d, 0x20, 0x2e, 0x2d, 0x2e, 0x2e,
#                0x20, 0x2e, 0x2d, 0x2e, 0x2e, 0x20, 0x2e, 0x2e, 0x20, 0x2d, 0x2e, 0x20, 0x2d, 0x2d, 0x2e]

def concat_bytes(byte0, byte1, byte2, byte3):
    return (byte0 << 24) | (byte1 << 16) | (byte2 << 8) | (byte3 << 0)

def split_word(word):
    return [(word >> 24) & 0xFF, (word >> 16) & 0xFF, (word >> 8) & 0xFF, (word >> 0) & 0xFF]

#accepts array of 32 bit words, length is in bytes
async def write_encoded_message(tqv, data, length):
    tqv.dut._log.info("Began write\n")
    tqv.dut.ui_in = 0
    for i in range(0, math.floor(length/4)):
        tqv.write_word_reg(i, concat_bytes(data[4*i + 0], data[4*i + 1], data[4*i + 2], data[4*i + 3]))

async def read_decoded_message(tqv, length):
    tqv.dut._log.info("Began read\n")
    result = [0] * length
    for i in range(0, math.floor(length/4)):
        word = tqv.read_word_reg(i)
        result[4*i:4*i+4] = split_word(word)

def set_rs_parameters(tqv, n, k, generator_polynomial, irreducible_polynomial, first_consecutive_root):
    tqv.dut._log.info(f"Set n = {n}, k = {k}, g = {generator_polynomial}, q = {irreducible_polynomial}, fcr = {first_consecutive_root}\n")
    tqv.dut.ui_in = 1
    tqv.write_byte_reg(0, n)
    tqv.write_byte_reg(1, k)
    tqv.write_byte_reg(2, generator_polynomial)
    tqv.write_hword_reg(3, irreducible_polynomial)
    tqv.write_byte_reg(4, first_consecutive_root)

@cocotb.test()
async def test_project(dut):
    dut._log.info("Start")

    # Set the clock period to 100 ns (10 MHz)
    clock = Clock(dut.clk, 100, units="ns")
    cocotb.start_soon(clock.start())

    # Interact with your design's registers through this TinyQV class.
    # This will allow the same test to be run when your design is integrated
    # with TinyQV - the implementation of this class will be replaces with a
    # different version that uses Risc-V instructions instead of the SPI test
    # harness interface to read and write the registers.
    tqv = TinyQV(dut, PERIPHERAL_NUM)

    # Reset
    await tqv.reset()

    dut._log.info("Test project behavior")

    #primitive polynomial: ccsds 0b110000111
    #primitive polynomials: 0b100101011 0b101011111 0b111110101

    #reed solomon parameters used in voyager
    #set_rs_parameters(tqv, n = 255, k = 223, irreducible_polynomial = 0b100011101)

    #ccsds parameters
    #ccsds 0x187
    set_rs_parameters(tqv, n = 255, k = 223, generator_polynomial = 0xE8, irreducible_polynomial = 0b110000111, first_consecutive_root = 0x79)

    await write_encoded_message(tqv, msg_encoded, len(msg_encoded))
    #should probably be wfi or something
    loop_counter = 0
    dut._log.info(loop_counter)
    while(1):
        await ClockCycles(tqv.dut.clk, 1000)
        dut._log.info(tqv.dut.uo_out)
        loop_counter = loop_counter + 1
    dut._log.info(loop_counter)
    tqv.dut.ui_in.value = 2
    await ClockCycles(tqv.dut.clk, 2)
    tqv.dut.ui_in.value = 0

    while(tqv.dut.uo_out.value == 0):
        loop_counter = loop_counter + 1
    dut._log.info(loop_counter)
    tqv.dut.ui_in.value = 2
    await ClockCycles(tqv.dut.clk, 2)
    tqv.dut.ui_in.value = 0

    while(tqv.dut.uo_out.value == 0):
        loop_counter = loop_counter + 1
    dut._log.info(loop_counter)
    tqv.dut.ui_in.value = 2
    await ClockCycles(self.dut.clk, 2)
    tqv.dut.ui_in.value = 0

    while(tqv.dut.uo_out.value == 0):
        loop_counter = loop_counter + 1
    dut._log.info(loop_counter)
    tqv.dut.ui_in.value = 2
    await ClockCycles(self.dut.clk, 2)
    tqv.dut.ui_in.value = 0
    #dut.interrupt 

    await print(read_decoded_message(tqv, 223))
